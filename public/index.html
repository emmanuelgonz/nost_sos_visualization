<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Satellite Position Visualization</title>
    <!-- Include Cesium JS and CSS -->
    <script src="https://cesium.com/downloads/cesiumjs/releases/1.88/Build/Cesium/Cesium.js"></script>
    <link href="https://cesium.com/downloads/cesiumjs/releases/1.88/Build/Cesium/Widgets/widgets.css" rel="stylesheet">

    <!-- Include Keycloak JS -->
    <script src="https://cdn.jsdelivr.net/npm/keycloak-js@20.0.2/dist/keycloak.min.js"></script>

    <style>
        #cesiumContainer {
            width: 100%;
            height: 100vh;
            margin: 0;
            padding: 0;
        }
        #controls {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(42, 42, 42, 0.8);
            padding: 10px;
            border-radius: 5px;
            color: white;
        }
    </style>
</head>
<body>
    <div id="cesiumContainer"></div>
    <div id="controls">
        <h3>Layer Selection</h3>
        <hr>

        <h4>Focal Area Extents</h4>
        <label>
            <input type="checkbox" id="toggleMissouriLayer" checked>
            Missouri River Basin Layer
        </label>
        <br>

        <h4>Optimization Layers</h4>
        <label>
            <input type="checkbox" id="toggleSnowLayer" >
            Snow
        </label>
        <br>
        <label>
            <input type="checkbox" id="toggleResolutionLayer">
            Resolution
        </label>
        <br>

        <br>
        <label>
            <input type="checkbox" id="toggleSweChangeLayer" checked>
            Snow Water Equivalent Change
        </label>
        <br>

        <!-- <label>
            <input type="checkbox" id="toggleOptimizationLayer" checked>
            Optimization - Selected Locations
        </label>
        <br> -->
        <label>
            <input type="checkbox" id="toggleOptimizationLayerAll" checked>
            Optimization - All Locations
        </label>
        <br>
        <label>
            <input type="checkbox" id="toggleOptimizationLayerSelected" checked>
            Optimization - Selected Locations
        </label>
        <br>
        <h4>Reward Layers</h4>
        <label>
            <input type="checkbox" id="toggleGcomLayer">
            GCOM-W
        </label>
        <br>
        <label>
            <input type="checkbox" id="toggleCapellaLayer">
            Capella 14
        </label>
    </div>
    <script type="module">
        import { AMQPWebSocketClient } from './js/amqp-websocket-client.mjs';

        // Keycloak configuration for user authentication
        const keycloak = new Keycloak({
            url: `https://nost.smce.nasa.gov:8443/`, // Replace with your Keycloak server URL
            realm: `NOS-T`,               // Replace with your Keycloak realm
            clientId: `sos_nodejs`         // Replace with your Keycloak client ID
        });

        keycloak.init({ onLoad: 'login-required' }).then(function(authenticated) {
            if (authenticated) {
                startApplication();
            } else {
                console.error('User not authenticated');
            }
        }).catch(function() {
            console.error('Failed to initialize Keycloak');
        });

        function startApplication() {
            // Fetch environment variables with the token
            fetch('/sos/env', {
                headers: {
                    'Authorization': 'Bearer ' + keycloak.token
                }
            })
            .then(response => response.json())
            .then(env => {
                const CESIUM_ACCESS_TOKEN = env.TOKEN;
                const BROKER_HOST = env.HOST;
                const RABBITMQ_RELAY_PORT = env.RABBITMQ_RELAY_PORT;
                const AUTH_PORT = env.KEYCLOAK_PORT;
                const BROKER_CLIENT_ID = env.CLIENT_ID;
                const BROKER_CLIENT_SECRET = env.CLIENT_SECRET_KEY;
                const KEYCLOAK_REALM = env.KEYCLOAK_REALM;

                Cesium.Ion.defaultAccessToken = CESIUM_ACCESS_TOKEN;

                const viewer = new Cesium.Viewer('cesiumContainer');
                const positions = {};
                const previousSensorCircles = {};
                let firstUpdate = true;
                let previousLabelEntities = {};
                let snowLayer, resolutionLayer;
                let optimizationLayer, optimizationLayerAll, optimizationLayerSelected, missouriLayer;
                let gcomLayer, capellaLayer;

                // // Load the optimization GeoJSON file
                // Cesium.GeoJsonDataSource.load('/sos/spatial/Optimization_result.geojson', {
                //     clampToGround: false,
                //     fill: Cesium.Color.YELLOW.withAlpha(0.8),
                // }).then(function (dataSource) {
                //     optimizationLayer = dataSource;
                //     viewer.dataSources.add(dataSource);
                //     viewer.zoomTo(dataSource);
                // }).otherwise(function (error) {
                //     console.error(error);
                // });

                // Load the Missouri River Basin GeoJSON file
                Cesium.GeoJsonDataSource.load('/sos/spatial/WBD_10_HU2_4326.geojson', {
                    clampToGround: false,
                    stroke: Cesium.Color.RED,
                    fill: Cesium.Color.RED.withAlpha(0.0),
                }).then(function (dataSource) {
                    missouriLayer = dataSource;
                    viewer.dataSources.add(dataSource);
                    viewer.zoomTo(dataSource);
                }).otherwise(function (error) {
                    console.error(error);
                });

                // // Event listeners for toggling vector layers
                // document.getElementById('toggleOptimizationLayer').addEventListener('change', function() {
                //     if (optimizationLayer) {
                //         optimizationLayer.show = this.checked;
                //     }
                // });
                // Event listeners for toggling vector layers
                document.getElementById('toggleOptimizationLayerAll').addEventListener('change', function() {
                    if (optimizationLayerAll) {
                        optimizationLayerAll.show = this.checked;
                    }
                });

                // Event listeners for toggling vector layers
                document.getElementById('toggleOptimizationLayerSelected').addEventListener('change', function() {
                    if (optimizationLayerSelected) {
                        optimizationLayerSelected.show = this.checked;
                    }
                });

                document.getElementById('toggleMissouriLayer').addEventListener('change', function() {
                    if (missouriLayer) {
                        missouriLayer.show = this.checked;
                    }
                });

                // Function to handle incoming messages
                function handleMessage(topic, payload) {
                    // Your existing message handling code goes here
                    // For brevity, placeholder code is used

                    if (topic === "sos.manager.init") {
                        console.log("Initialize command received.");
                        viewer.clockViewModel.currentTime = Cesium.JulianDate.fromIso8601(payload.taskingParameters.simStartTime);
                        viewer.clockViewModel.startTime = Cesium.JulianDate.fromIso8601(payload.taskingParameters.simStartTime);
                        viewer.clockViewModel.stopTime = Cesium.JulianDate.fromIso8601(payload.taskingParameters.simStopTime);
                        viewer.clockViewModel.clockRange = Cesium.ClockRange.CLAMPED;
                        viewer.timeline.zoomTo(viewer.clockViewModel.startTime, viewer.clockViewModel.stopTime);
                    } else if (topic === "sos.manager.start") {
                        console.log("Start command received.");
                        viewer.clockViewModel.multiplier = payload.taskingParameters.timeScalingFactor;
                    } else if (topic == "sos.manager.time" || topic == "sos.manager.status.time") {
                        console.log("Time message received.");
                        viewer.clockViewModel.currentTime = Cesium.JulianDate.fromIso8601(payload.properties.simTime);
                        viewer.timeline.updateFromClock();
                    } else if (topic === "sos.manager.update") {
                        console.log("Update message received.");
                        viewer.clockViewModel.multiplier = payload.taskingParameters.timeScalingFactor;
                    } else if (topic === "sos.manager.stop") {
                        console.log("Stop command received.");
                        viewer.clockViewModel.multiplier = 0;
                    } else if (topic === "sos.constellation.location") {
                        const position = new Cesium.Cartesian3(payload.ecef[0], payload.ecef[1], payload.ecef[2]);
                        const altitude_km = payload.altitude / 1000;
                        const radius_km = payload.radius / 1000;
                        const swath_km = payload.swath / 1000;

                        if (!positions[payload.name]) {
                            positions[payload.name] = [];
                        }
                        positions[payload.name].push(position);

                        if (previousSensorCircles[payload.name]) {
                            previousSensorCircles[payload.name].forEach(circle => {
                                viewer.scene.primitives.remove(circle);
                            });
                            previousSensorCircles[payload.name].length = 0;
                        } else {
                            previousSensorCircles[payload.name] = [];
                        }

                        if (previousLabelEntities[payload.name]) {
                            viewer.entities.remove(previousLabelEntities[payload.name]);
                        }

                        let color = Cesium.Color.RED;
                        if (payload.name === 'GCOM-W1 (SHIZUKU)') {
                            color = Cesium.Color.GREEN;
                        } else if (payload.name === 'CAPELLA-14 (ACADIA-4)') {
                            color = Cesium.Color.YELLOW;
                        }

                        const dotcolor = payload.state ? Cesium.Color.LIME : Cesium.Color.RED;

                        previousLabelEntities[payload.name] = viewer.entities.add({
                            position: position,
                            point: {
                                pixelSize: 10,
                                color: dotcolor,
                            },
                            label: {
                                text: payload.name,
                                font: '10pt Arial',
                                style: Cesium.LabelStyle.FILL,
                                fillColor: dotcolor,
                                verticalOrigin: Cesium.VerticalOrigin.BOTTOM,
                                pixelOffset: new Cesium.Cartesian2(0, -15),
                                eyeOffset: new Cesium.Cartesian3(0, 0, -5000),
                            }
                        });

                        const sensorRadius = payload.radius;
                        const sensorHeight = payload.altitude;
                        const hollowRadius = payload.radius * (5 / 50);

                        const outerCone = new Cesium.CylinderGeometry({
                            length: sensorHeight * 2,
                            topRadius: 0.0,
                            bottomRadius: sensorRadius,
                            vertexFormat: Cesium.PerInstanceColorAppearance.VERTEX_FORMAT
                        });

                        const outerConeInstance = new Cesium.GeometryInstance({
                            geometry: outerCone,
                            modelMatrix: Cesium.Matrix4.multiplyByTranslation(
                                Cesium.Transforms.eastNorthUpToFixedFrame(position),
                                new Cesium.Cartesian3(0.0, 0.0, -sensorHeight),
                                new Cesium.Matrix4()
                            ),
                            attributes: {
                                color: Cesium.ColorGeometryInstanceAttribute.fromColor(color.withAlpha(0.2))
                            }
                        });

                        const outerPrimitive = new Cesium.Primitive({
                            geometryInstances: outerConeInstance,
                            appearance: new Cesium.PerInstanceColorAppearance()
                        });

                        viewer.scene.primitives.add(outerPrimitive);
                        previousSensorCircles[payload.name].push(outerPrimitive);

                        if (payload.name === "CAPELLA-14 (ACADIA-4)") {
                            const innerCone = new Cesium.CylinderGeometry({
                                length: sensorHeight * 2,
                                topRadius: 0.0,
                                bottomRadius: hollowRadius,
                                vertexFormat: Cesium.PerInstanceColorAppearance.VERTEX_FORMAT
                            });

                            const innerConeInstance = new Cesium.GeometryInstance({
                                geometry: innerCone,
                                modelMatrix: Cesium.Matrix4.multiplyByTranslation(
                                    Cesium.Transforms.eastNorthUpToFixedFrame(position),
                                    new Cesium.Cartesian3(0.0, 0.0, -sensorHeight),
                                    new Cesium.Matrix4()
                                ),
                                attributes: {
                                    color: Cesium.ColorGeometryInstanceAttribute.fromColor(Cesium.Color.BLACK.withAlpha(0.6))
                                }
                            });

                            const innerPrimitive = new Cesium.Primitive({
                                geometryInstances: innerConeInstance,
                                appearance: new Cesium.PerInstanceColorAppearance()
                            });

                            viewer.scene.primitives.add(innerPrimitive);
                            previousSensorCircles[payload.name].push(innerPrimitive);
                        }

                        if (!positions[payload.name]) {
                            positions[payload.name] = [];
                        }

                        if (positions[payload.name].polylineEntity) {
                            viewer.entities.remove(positions[payload.name].polylineEntity);
                        }

                        if (positions[payload.name].length > 1) {
                            positions[payload.name].polylineEntity = viewer.entities.add({
                                polyline: {
                                    positions: positions[payload.name],
                                    width: 0.5,
                                    material: color
                                }
                            });
                        }
                    } else if (topic === "sos.snow.layer") {
                        handleLayerMessage(payload, 'snow_layer', 'toggleSnowLayer');
                    } else if (topic === "sos.resolution.layer") {
                        handleLayerMessage(payload, 'resolution_layer', 'toggleResolutionLayer');
                    } else if (topic === "sos.gcom.layer") {
                        handleLayerMessage(payload, 'gcom_layer', 'toggleGcomLayer');
                    } else if (topic === "sos.capella.layer") {
                        handleLayerMessage(payload, 'capella_layer', 'toggleCapellaLayer');
                    } else if (topic === "sos.swe_change.layer") {
                        handleLayerMessage(payload, 'swe_change_layer', 'toggleSweChangeLayer');
                    } else if (topic === "sos.swe_change.all") {
                        handleIncomingMessage(payload, "all");
                    } else if (topic === "sos.swe_change.selected") {
                        handleIncomingMessage(payload, "selected");
                    }
                }

                // function handleLayerMessage(payload, layerName, toggleId) {
                //     console.log('Handling layer message:', layerName);
                //     let layer;
                //     const checkbox = document.getElementById(toggleId);

                //     if (checkbox.checked) {
                //         const layerImage = `data:image/png;base64,${payload[layerName]}`;
                //         layer = new Cesium.ImageryLayer(
                //             new Cesium.SingleTileImageryProvider({
                //                 url: layerImage,
                //                 rectangle: Cesium.Rectangle.fromDegrees(
                //                     payload.top_left[0], payload.bottom_right[1], 
                //                     payload.bottom_right[0], payload.top_left[1]
                //                 )
                //             })
                //         );
                //         viewer.scene.imageryLayers.add(layer);
                //     }

                //     checkbox.addEventListener('change', function() {
                //         if (layer) {
                //             layer.show = this.checked;
                //         } else if (this.checked) {
                //             const layerImage = `data:image/png;base64,${payload[layerName]}`;
                //             layer = new Cesium.ImageryLayer(
                //                 new Cesium.SingleTileImageryProvider({
                //                     url: layerImage,
                //                     rectangle: Cesium.Rectangle.fromDegrees(
                //                         payload.top_left[0], payload.bottom_right[1], 
                //                         payload.bottom_right[0], payload.top_left[1]
                //                     )
                //                 })
                //             );
                //             viewer.scene.imageryLayers.add(layer);
                //         }
                //     });

                //     return function updateLayer(newPayload) {
                //         const newLayerImage = `data:image/png;base64,${newPayload[layerName]}`;
                //         const newLayer = new Cesium.ImageryLayer(
                //             new Cesium.SingleTileImageryProvider({
                //                 url: newLayerImage,
                //                 rectangle: Cesium.Rectangle.fromDegrees(
                //                     newPayload.top_left[0], newPayload.bottom_right[1], 
                //                     newPayload.bottom_right[0], newPayload.top_left[1]
                //                 )
                //             })
                //         );
                //         viewer.scene.imageryLayers.remove(layer);
                //         layer = newLayer;
                //         viewer.scene.imageryLayers.add(layer);
                //         console.log('Layer updated.');
                //         layer.show = checkbox.checked;
                //     };
                // }

                // Function to handle the incoming message
                function handleIncomingMessage(payload, layerType) {
                    // Parse the message to get the GeoJSON data
                    const geoJsonData = JSON.parse(payload.vector_layer);

                    // Determine the color based on the layerType
                    const color = layerType === 'all' ? Cesium.Color.GRAY : Cesium.Color.YELLOW;

                    // Load the GeoJSON data from the string
                    Cesium.GeoJsonDataSource.load(geoJsonData, {
                    clampToGround: false,
                    stroke: color,
                    fill: color.withAlpha(0.5),
                    }).then(function (dataSource) {
                    if (layerType === 'all') {
                        if (optimizationLayerAll) {
                        // Remove the existing all layer
                        viewer.dataSources.remove(optimizationLayerAll);
                        }
                        optimizationLayerAll = dataSource;
                    } else if (layerType === 'selected') {
                        if (optimizationLayerSelected) {
                        // Remove the existing selected layer
                        viewer.dataSources.remove(optimizationLayerSelected);
                        }
                        optimizationLayerSelected = dataSource;
                    }
                    viewer.dataSources.add(dataSource);
                    // viewer.zoomTo(dataSource);
                    }).otherwise(function (error) {
                    console.error(error);
                    });
                }

                function handleLayerMessage(payload, layerName, toggleId) {
                    // Remove any existing layer with the same name
                    const layers = viewer.scene.imageryLayers;
                    for (let i = layers.length - 1; i >= 0; i--) {
                        const existingLayer = layers.get(i);
                        if (existingLayer.layerName === layerName) {
                            layers.remove(existingLayer, true);
                        }
                    }

                    console.log('Handling layer message:', layerName);
                    let layer;
                    const checkbox = document.getElementById(toggleId);

                    if (checkbox.checked) {
                        const layerImage = `data:image/png;base64,${payload[layerName]}`;
                        layer = new Cesium.ImageryLayer(
                            new Cesium.SingleTileImageryProvider({
                                url: layerImage,
                                rectangle: Cesium.Rectangle.fromDegrees(
                                    payload.top_left[0], payload.bottom_right[1],
                                    payload.bottom_right[0], payload.top_left[1]
                                )
                            })
                        );
                        layer.layerName = layerName;
                        viewer.scene.imageryLayers.add(layer);
                    }

                    checkbox.addEventListener('change', function() {
                        if (layer) {
                            layer.show = this.checked;
                        } else if (this.checked) {
                            const layerImage = `data:image/png;base64,${payload[layerName]}`;
                            layer = new Cesium.ImageryLayer(
                                new Cesium.SingleTileImageryProvider({
                                    url: layerImage,
                                    rectangle: Cesium.Rectangle.fromDegrees(
                                        payload.top_left[0], payload.bottom_right[1], 
                                        payload.bottom_right[0], payload.top_left[1]
                                    )
                                })
                            );
                            layer.layerName = layerName;
                            viewer.scene.imageryLayers.add(layer);
                        }
                    });
                }
                // Handle the WebSocket connection and events
                const tls = window.location.protocol === "https:";
                const url = `${tls ? "wss" : "ws"}://${BROKER_HOST}:${RABBITMQ_RELAY_PORT}`;
                console.log(`Connecting to ${url}`);

                let accessToken;

                function fetchAccessToken() {
                    return fetch(`https://${BROKER_HOST}:${AUTH_PORT}/realms/${KEYCLOAK_REALM}/protocol/openid-connect/token`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/x-www-form-urlencoded'
                        },
                        body: new URLSearchParams({
                            'client_id': BROKER_CLIENT_ID,
                            'client_secret': BROKER_CLIENT_SECRET,
                            'grant_type': 'client_credentials'
                        })
                    }).then(response => {
                        if (response.ok) {
                            return response.json();
                        } else {
                            return response.text().then(text => {
                                console.error("Failed to obtain access token:", text);
                                throw new Error('Failed to obtain access token');
                            });
                        }
                    }).then(data => {
                        console.log("Access token obtained.");
                        accessToken = data.access_token;
                        return accessToken;
                    }).catch(error => {
                        console.error(error);
                    });
                }

                function startTokenRefresh(conn) {
                    setInterval(() => {
                        fetchAccessToken().then(newToken => {
                            if (newToken) {
                                accessToken = newToken;
                                conn.updateSecret(accessToken);
                                console.log("Access token refreshed.");
                            }
                        });
                    }, 3 * 60 * 1000); // Refresh every 3 minutes
                }

                fetchAccessToken().then(token => {
                    if (token) {
                        accessToken = token;
                        const amqp = new AMQPWebSocketClient(url, "/", "", accessToken);
                        async function start(amqp) {
                            try {
                                const conn = await amqp.connect();
                                const ch = await conn.channel();
                                console.log("Connected to the broker.");
                                await ch.exchangeDeclare("sos", "topic", { durable: false, autoDelete: true });
                                const q = await ch.queue("", { exclusive: true });
                                await q.bind("sos", "sos.#");
                                await q.subscribe({ noAck: true }, (msg) => {
                                    const topic = msg.routingKey;
                                    const payload = JSON.parse(msg.bodyToString());
                                    handleMessage(topic, payload);
                                });

                                startTokenRefresh(conn);
                            } catch (err) {
                                console.error("Error during AMQP setup:", err);
                            }
                        }
                        start(amqp);
                    }
                });
            })
            .catch(error => {
                console.error('Error fetching /env:', error);
            });
        }
    </script>
</body>
</html>